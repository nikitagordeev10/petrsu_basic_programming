# Программа для получения вектора из матрицы
#  b(i) = A(k,i) + A(i,l)

# ======================== Инициализация ======================== 

.include "my-macro"                 # подключение файла с макроопределениями

.bss
    .lcomm c, 1                     # однобайтовый буфер для чтения байта из файла stdin

.data                               # секция данных, распределение памяти
matrix:                             # Двумерный массив 6 x 6
    .long 1, 2, 3, 4, 5, 6
    .long 7, 8, 9, 10, 11, 12
    .long 13, 14, 15, 16, 17, 18
    .long 19, 20, 21, 22, 23, 24
    .long 25, 26, 27, 28, 29, 30
    .long 31, 32, 33, 34, 35, 36

k: .long 0                          # Четырехбайтовые элементы матрицы
l: .long 0                          # Четырехбайтовые элементы матрицы

vector:
    .long 0, 0, 0, 0, 0, 0          # Четырехбайтовые элементы матрицы

vector_size: .long 6

printf_format:
    .string "%d\n"                  # форматная строка для printf

.text                               # секция команд процесора
.globl main                         # точка входа - глобальная метка

# ======================== Запуск программы ======================== 

main:

# ------------------------ Получение k из stdin ------------------------ 

k_prompt:
    Puts "Введите k от 1 до 6: "

k_input:
    Getchar $c                      # макровызов ввода символа из stdin

    cmpl $0, %eax                   # наступило событие EOF (конец файла stdin) ?
    je uninputted_k_or_l            # Да - вывод ошибки

    cmpb $'\n', c                   # Это символ перевода строки ?
    je check_k                      # ДА - на проверку ввода
    
    movl c, %eax                    # Загрузить константу в регистр %eax
    movl %eax, k                    # Сохранение последнего прочитанного символа из регистра в переменную л
    jmp k_input                     # На ввод следующего символа ('\n')

check_k:
    cmpb $'6', k                    # код больше кода символа '6' ?
    ja k_prompt                     # ДА - ввод снова
    cmpb $'1', k                    # код меньше кода символа '1' ?
    jb k_prompt                     # ДА - ввод снова

    movl k, %eax                    # Загрузить константу в регистр %eax.
    subl $49, %eax                  # Индекс значения k
    movl %eax, k                    # Запись значения k

# ------------------------ Получение l из stdin ------------------------ 

l_prompt:
    Puts "Введите l от 1 до 6: "

l_input:
    Getchar $c                      # макровызов ввода символа из stdin в

    cmpl $0, %eax                   # наступило событие EOF (конец файла stdin) ?
    je uninputted_k_or_l            # Да - вывод ошибки

    cmpb $'\n', c                   # это символ перевода строки ?
    je check_l                      # ДА - на проверку ввода
    
    movl c, %eax                    # Загрузить константу в регистр %eax
    movl %eax, l                    # Сохранение последнего прочитанного символа из регистра в переменную l
    jmp l_input                     # На ввод следующего символа ('\n')

check_l:
    cmpb $'6', l                    # код больше кода символа '6' ?
    ja not_1_to_6                     # ДА - ввод снова
    cmpb $'1', l                    # код меньше кода символа '1' ?
    jb not_1_to_6                     # ДА - ввод снова

    movl l, %eax                    # Загрузить константу в регистр %eax.
    subl $49, %eax                  # Индекс значения l
    movl %eax, l                    # Запись значения l

# подготовка к вычислениям

    movl $0, %esi                   # позиция 0, esi индексный счётчик
    jmp get_vector                  # Получение вектора

# ------------------------ Проверки k и l ------------------------ 

not_1_to_6:
    Puts "Не вверный ввод числа (вне диапазона 0~5). Завершение программы."
    jmp l_prompt

uninputted_k_or_l:
    Puts "Не было введено k или l. Завершение программы"
    jmp l_prompt

# ------------------------ Получение вектора по формуле b(i) = A(k,i) + A(i,l) ------------------------ 

get_vector:

# столбец "x"
    movl %esi, %eax                 # Т.к. умножать можно только eax
    
    mull vector_size                # Находим координату по "x". Умножаем на eax
    addl k, %eax                    # В eax координата по х (отсчёт с 0)
    
    movl $4, %ebx                   # Вносим 4 в ebx
    mull %ebx                       # Домножаем eax, потому что размер матрицы long (4 байта)

    movl matrix(%eax), %eax         # Запишем значение из матрицы в %eax
    movl %eax, vector(, %esi, 4)    # !!! В вектор помещено значение из матрицы

# строка "y"
    movl l, %eax                    # Поместили значение столбца в регистр eax

    mull vector_size                # Находим координату по "y". Умножаем на eax
    addl %esi, %eax                 # Позиция с учётом перемещения в eax 
    
    movl $4, %ebx                   # Вносим 4 в ebx
    mull %ebx                       # Потому что размер матрицы long (4 байта)
    
    leal vector(, %esi, 4), %ebx    # Указатель на ячейку с записаным значением строки 
    movl matrix(%eax), %eax         # !!! Получили значение по столбцу в %eax

# запись в вектор    
    addl %eax, (%ebx)               # !!! В вектор добавлено значение по столбцу

# счётчик
    incl %esi                       # от 1 до 6

    cmpl $6, %esi                   # Сравнение длины вектора
    jl get_vector                   # Если операнды не равны перейти на метку

# ------------------------ Вывод с помощью функции printf входящей в библиотеку glibc, из функции на языке ассемблера ------------------------

print_vector:
    Puts "Полученный вектор: "      
    movl $0, %esi                   # Обнуление индексного счётчика

print_element:                     
    movl vector(, %esi, 4), %eax    # Запишем значение из матрицы в %eax

    # следующий код выводит число в %eax на экран
    pushl %eax                          
    pushl $printf_format            
    call printf
    addl $8, %esp                   

    incl %esi                       # от 1 до 6
    cmpl vector_size, %esi          # Сравнение длины вектора
    jl print_element                # Вывод следудющейго элемента

# ------------------------ Завершение программы ------------------------ 

stop:
    Exit $0                         

.end

# ------------------------ Пример матрицы 1------------------------ 
# ---------------------> i
#  1  ( 2)   3   4   5   6 |
#  7  ( 8)   9  10  11  12 |
#(13) (14) (15)(16)(17)(18)|
# 19  (20)  21  22  23  24 |
# 25  (26)  27  28  29  30 v
# 31  (32)  33  34  35  36 j
# 
# ] k = 2, l = 3
# b(1) = A(k,1) + A(1,l) =  2 + 13 = 15
# b(2) = A(k,2) + A(2,l) =  8 + 14 = 22
# b(3) = A(k,3) + A(3,l) = 14 + 15 = 29
# b(4) = A(k,4) + A(4,l) = 20 + 16 = 36
# b(5) = A(k,5) + A(5,l) = 26 + 17 = 43
# b(6) = A(k,6) + A(6,l) = 32 + 18 = 50


# ------------------------ Пример матрицы 2 ------------------------ 
#  b(i) = A(k,i) + A(i,l)
# ---------------------> i
#  1   2   3   4   5  (6) |
#  7   8   9  10  11 (12) |
# 13  14  15  16  17 (18) |
# 19  20  21  22  23 (24) | 
# 25  26  27  28  29 (30) v
#(31)(32)(33)(34)(35)(36) j
# 
# ] k = 6, l = 6
# b(1) = A(k,1) + A(1,l) =  6 + 31 = 37
# b(2) = A(k,2) + A(2,l) = 12 + 32 = 44
# b(3) = A(k,3) + A(3,l) = 18 + 33 = 51
# b(4) = A(k,4) + A(4,l) = 24 + 34 = 58
# b(5) = A(k,5) + A(5,l) = 30 + 35 = 65
# b(6) = A(k,6) + A(6,l) = 36 + 36 = 72