/* программа вычисления и вывода (в стандартный вывод) суммы одноцифровых чисел. */

.include "my-macro"		# подключение файла с макроопределениями

.data				# определения данных программы
	sum: .word 0		# переменная для суммы
	str_len: .long 0	# переменная - количество цифр в числе для вывода
	
.bss				# Block Started by Symbol
    .lcomm c, 1		# буфер для чтения байта из файла stdin. Размер -- 1 байт
    .lcomm n, 1		# буфер для хранения цифр
    .lcomm buf_output, 2	# буфер для вывода. Размер -- 2 байта

.text

.global _start

_start:

show_prompt:
    Puts "Вводите цифру от '0' до '9'" # макровызов вывода строки в файл stdout 

kbd_input:
    Getchar $c			# макровызов ввода байта из stdin в промежуточный буфер c

    cmpl $0, %eax		# наступило событие EOF (конец файла stdin)?
    	je stop		# да -> на завершение программы

    cmpb $'\n', c		# это символ перевода строки ?
	je sum_num		# да -> идем записывать предшествующий символ в eax

    cmpb $'9', c		# код больше кода символа '9'?
    	ja print_err_msg	# да -> на вывод сообщения об ошибке

    cmpb $'0', c		# код меньше кода символа '0'?
    	jb print_err_msg	# да -> на вывод сообщения об ошибке

    movb c, %al		# копируем значение из с %al		
    movb %al, n		# копируем значение из с %al

    jmp kbd_input

sum_num:
	xorl %eax, %eax	# обнуление %eax

	movb n, %al		# передаем в %al число
	subb $'0', %al		# получаем числовое значение
	addw %ax, sum		# прибавляем число к сумме
	jc print_err_of	# проверка на переполнение
	
nextdigit_10:			# Подготовка к вычислениям
    movw $10, %bx		# в %ebx копируем текущую СС 
    movl $4, %esi		# передаем в esi адрес первого элемента 
    movw sum, %ax		# копируем сумму в %eax
    xorl %edi, %edi		# обнуление %edi. Будем записывать итоговый буфер вывода
	xorl %ecx, %ecx	# обнуление %ecx. Будет счетчик цикла длины строки вывода

get_str_len_10:		# Получение количество цифр в числе для вывода
    incl %ecx			# увеличение длины строки вывода
    xorl %edx, %edx		# обнуление %edx. хранения остатка
    divw %bx			# делим %ax на %bx, остаток в %dx, в %ax храним целую часть
    addb $'0', %dl		# получаем код числа. (add, т.к. при перемещении %dl в buf_output у содерижмого отнимается 48)
    movb %dl, buf_output(%esi) # копируем содержимое %edx в буфер по нужному смещению

    cmpw $0, %ax		# дошли до нуля? (в %ax пусто?)
    	je additional_10	# да -> заканчиваем преобразование и готовим буфер к выводу

    decl %esi			# нет -> уменьшаем %esi на 1
    jmp get_str_len_10		# и переходим в начало циклa
    
additional_10:			# Подготовка аргументов для системного вызова
	movl %ecx, str_len	# отправляем полученный %ecx в качестве значения длины строки
	lea buf_output(%esi), %ecx 	# параметр системного вызова 2: адрес памяти с выводимыми символами
					# загружает адрес первого символа в ecx 
					# buf_output - адрес строки
					# esi - индекс первой цифры числа
					# ecx = buf_output + esi
					
					# будет использоваться в системном вызове, в ecx хранится адрес строки которая выводится

output_10:				# вывод суммы
	movl $4, %eax			# поместить номер системного вызова
                                	# write = 4 в регистр %eax 
	
	movl $1, %ebx			# параметр системного вызова 1: дескриптор стандартного вывода в регистр %ebx;
                                 	# номер файлового дескриптора stdout - 1 
                                 	
	movl str_len, %edx		# параметр системного вызова 3: количество байтов для вывода
	
	int $0x80			# выполнить системный вызов, вывод числа на экран

	Puts ""
	jmp show_prompt		# Начать выполнение с начала
					# 1,2,3 - нумерация, как они стоят при вызове системных функций в Си

print_err_msg:
    Puts "Ошибка: не цифровая клавиша. повторите ввод"
    jmp kbd_input

print_err_of:
    Puts "Ошибка: переполнение буфера\n"
    jmp stop

stop:
    Exit $0

.end
