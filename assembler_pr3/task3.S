/*
 * Программа ввода кодов цифровых символов в буфер в ОП
 */

/*
 * Ассемблирование: as -ahlsm=task3.lst --32 -gstabs+ -o task3.o task3.S
 * Редактирование связей: ld -melf_i386 -o task3-exe-S task3.o
 * Запуск отладчика: kdbg task3-exe-S
*/
	
.include "my-macro"

.bss
    .lcomm buf, 100			# 100 байтовый буфер для кодов прочитанных символов
    .lcomm c, 1    			# однобайтовый буфер для чтения байта из файла stdin

/* 
 * bss используется для Секция bss используется для хранения неинициализированных данных, байты 
 * которых при запуске программы имеют нулевые значения. Данные этой секции не хранятся в объектном
 * и исполняемом файлах, память для неё распределяет загрузчик исполняемого файла. Символьные имена
 * в секции bss определяются директивой .lcomm, задающей имя и длину выделямой ему области ОП в 
 * байтах.
*/
	
.text
.global _start

_start:
    sub    %esi, %esi     		# указатель адреса байта в буфере buf (индексный регистр)

show_prompt:
    Puts "Вводите цифру, друг мой!"	# макровызов вывода строки в
					# файл stdout (подсказка ввода)

kbd_input:
    Getchar $c          		# макровызов ввода байта из stdin в
					# промежуточный буфер c для анализа

    cmpl $0, %eax     			# наступило событие EOF (конец файла stdin) ?
    je stop        			# Да - на завершение программы
	
    cmpb $'\n', c     			# это символ перевода строки ?
    // je kbd_input			# ДА - на ввод следующего символа
    je eax_input			# ДА - на вывыод следующего предыдущего символа в %eax
    cmpb $'9', c      			# код больше кода символа '9' ?
    ja print_err_msg    		# ДА - на вывод сообщения об ошибке
    cmpb $'0', c    			# код меньше кода символа '0' ?
    jb print_err_msg    		# ДА - на вывод сообщения об ошибке

    movb c, %al         		# передать код символа цифры из c в al
    cmpl $100, %esi			# сравниваем esi с размером буфера
    je print_end_msg			# ДА - на вывод сообщения о заполнении буфера
    movb %al, buf(%esi) 		# передать код символа цифры из al в байт
					# буфера по адресу &buf + esi
    incl %esi       			# указать на следующий байт буфера для
					# следующего кода

    Puts "Цифра! Хорошо." 		# сообщения об успехе вводе

    jmp show_prompt    			# на ввод следующего символа

/*
 * Макроввызов и макрорасширение Getchar
 * Появление в исходном файле макровызова Getchar $c приводит к включению в этот
 * файл макрорасширения команд тела макроопределения, в котором формальный параметр
 * макроопределения buf_addr заменён на указанный в макровызове фактический параметр
 * $c, - адрес однобайтового буфера, определённого в секции .bss.
 * Затем для этого буфера формируются правильные команды запуска системного вызова read
*/

	
/*
 * Макровызов и макрорасширение Puts
 * Появление в исходном файле макровызова Puts "Цифра! Хорошо." приводит к включению к
 * этот файл макрорасширения (команд тела макроопределения), в котором формальный параметр
 * макроопределения string заменён на указанный в макровызове фактический параметр "Цифра! 
 * Хорошо."
*/
	
print_err_msg:
    Puts "Не цифровая клавиша. Повторите ввод"	# вывод сообщения об ошибке
    jmp show_prompt				# на ввод следующего символа

print_end_msg:
    Puts "Буфер переполнен"			# вывод сообщения о переполнении
    jmp stop					# завершение программы

eax_input:
    movl %esi, %ebx			# Копируем %esi в %ebx
    decl %ebx 				# Уменьшаем %ebx на 1
    cmpl $0, %ebx			# Сравниваем %ebx c 0
    jl kbd_input			# ДА - переход к началу программы
					# на ввод следующего символа
    movb buf(%ebx), %al 		# Копируем ячейку buf + %ebx в %al
    subb $'0', %al			# Отнимаем 30 от кода символа для получения числового
	 				# значения
    jmp kbd_input 			# Переход к началу программы
	
stop:
    Exit $0

.end

/*
 * Особенности кодировки символов - на какое значение отличается значение кода цифрового
 * символа от числового значения этой цифры.
 *
 * Однобайтовые коды цифровых символов - от кода "0"-48(0х30) до кода "9"-57(0x39)
 *
 * Значиние одноцифрового числа = значение кода - 48(0х40)
 *
 * Численные значения кодов цифровых символов удовлетворяют неравенству:
 * 0х30 <= Код. циф. Сим <= 0x39
*/

/*
 * Суффиксы
 * l   - 32 бит
 * w   - 16 бит
 * b   - 8 бит
 * 
 * Инструкции
 * cmp - CoMPare - сравнение
 * jmp - JuMP - безусловный переход
 * je  - Jump Equal - переход если равно
 * inc - INCrement - увеличение на единицу
 * mov - MOVe - перемещение значения из одного регистра в другой
 * sub - SUBTRACT - вычитание
*/ 
